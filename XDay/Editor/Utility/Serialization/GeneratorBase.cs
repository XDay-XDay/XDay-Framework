/*
 * Copyright (c) 2024 XDay
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace XDay.SerializationAPI.Editor
{
    internal class GeneratorBase
    {
        protected string GetFileName(SerializableClassInfo classInfo, bool save)
        {
            var dir = Path.GetDirectoryName(classInfo.FilePath);
            var parentName = Path.GetFileNameWithoutExtension(classInfo.FilePath);

            var postFix = save ? "Save" : "Load";
            var fileName = $"{dir}/{parentName}.{classInfo.ClassName}.{postFix}.cs";
            return fileName;
        }

        protected string GenerateFull(SerializableClassInfo classInfo, string functions)
        {
            var text = $@"
/*
    This file is auto generated by tool. if modify manually, you need remove [SLGSerializationClassAttribute] from class definition in case of being overridden!!!
*/

using XDay.SerializationAPI;

@NAMESPACE_BEGIN@
    {classInfo.Modifier} partial class {classInfo.ClassName}
    {{
        @FUNCTIONS@
    }}
@NAMESPACE_END@
";

            if (string.IsNullOrEmpty(classInfo.NamespaceName))
            {
                text = text.Replace("@NAMESPACE_BEGIN@", "");
                text = text.Replace("@NAMESPACE_END@", "");
            }
            else
            {
                text = text.Replace("@NAMESPACE_BEGIN@", $@"namespace {classInfo.NamespaceName} {{");
                text = text.Replace("@NAMESPACE_END@", $@"}}");
            }

            text = text.Replace("@FUNCTIONS@", functions);

            return text;
        }

        protected List<SerializableClassInfo> GetSerializableClassInfo()
        {
            var classes = new List<SerializableClassInfo>();

            var assemblies = AppDomain.CurrentDomain.GetAssemblies();

            foreach (var assembly in assemblies)
            {
                var allTypes = assembly.GetTypes();

                foreach (var type in allTypes)
                {
                    var attributes = type.GetCustomAttributes(typeof(XDaySerializableClassAttribute), false);
                    foreach (var attribute in attributes)
                    {
                        var slgAttribute = attribute as XDaySerializableClassAttribute;
                        
                        var classInfo = new SerializableClassInfo();
                        classes.Add(classInfo);
                        classInfo.ClassName = type.Name;
                        classInfo.ClassLabel = slgAttribute.Label;
                        classInfo.HasParentClass = type.BaseType != typeof(System.Object);
                        classInfo.NamespaceName = type.Namespace;
                        classInfo.Modifier = GetClassModifier(type);
                        classInfo.FilePath = SerializationHelper.GetClassFilePath(type.FullName);
                        classInfo.HasPostLoad = slgAttribute.HasPostLoad;

                        var fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

                        foreach (var field in fields)
                        {
                            var fieldAttributes = field.GetCustomAttributes(typeof(XDaySerializableFieldAttribute), false)
                                                    .Cast<XDaySerializableFieldAttribute>().ToArray();
                            if (fieldAttributes.Length > 0)
                            {
                                var fieldType = field.FieldType;
                                var fieldInfo = new SerializableClassFieldInfo();
                                classInfo.Fields.Add(fieldInfo);
                                fieldInfo.ContainerType = GetContainerType(fieldType);
                                if (fieldInfo.ContainerType == ContainerType.Array)
                                {
                                    fieldType = fieldType.GetElementType();
                                }
                                Type[] genericArguments = fieldType.GetGenericArguments();
                                if (genericArguments.Length > 0)
                                {
                                    fieldInfo.Type = genericArguments[0];
                                }
                                else
                                {
                                    fieldInfo.Type = fieldType;
                                }
                                fieldInfo.FieldType = GetFieldType(fieldInfo.Type);
                                fieldInfo.Name = field.Name;
                                fieldInfo.Label = fieldAttributes[0].Label;
                                fieldInfo.ExistedMinVersion = fieldAttributes[0].Version;
                            }
                        }
                    }
                }
            }

            return classes;
        }

        private FieldType GetFieldType(Type type)
        {
            if (type.IsArray)
            {
                type = type.GetElementType();
            }

            if (type == typeof(string) ||
                type.IsValueType ||
                type.IsPrimitive)
            {
                return FieldType.POD;
            }
            return FieldType.Compound;
        }

        private ContainerType GetContainerType(Type fieldType)
        {
            if (fieldType.IsArray)
            {
                return ContainerType.Array;
            }

            if (fieldType.IsGenericType)
            {
                if (fieldType.GetGenericTypeDefinition() == typeof(List<>))
                {
                    return ContainerType.List;
                }
            }

            return ContainerType.None;
        }

        private string GetClassModifier(Type type)
        {
            string modifier = GetAccessModifier(type);
            modifier += " ";

            // Additional checks for other modifiers
            if (type.IsAbstract && type.IsSealed)
            {
                modifier += "static";
            }
            else if (type.IsAbstract)
            {
                modifier += "abstract";
            }
            else if (type.IsSealed)
            {
                modifier += "sealed";
            }
            modifier += " ";
            return modifier;
        }

        private string GetAccessModifier(Type type)
        {
            if (type.IsNotPublic)
            {
                if (type.IsNested)
                {
                    if (type.IsNestedPrivate)
                    {
                        return "private";
                    }
                    else if (type.IsNestedAssembly)
                    {
                        return "internal";
                    }
                }
                else
                {
                    return "internal";
                }
            }
            
            return "public";
        }
    }
}
